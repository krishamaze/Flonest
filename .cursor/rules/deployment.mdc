---
alwaysApply: true
---

Deployment

Never use vercel deploy, vercel --prod, or vercel.

Always deploy using git push — it triggers Vercel automatically.
main branch = production deployment.

Use descriptive commit messages.

Only use Vercel CLI for: status, logs, env ls, inspect.

No localhost dev — test directly in production.

Desktop access allowed temporarily for Cursor automation.

Post-Push Deployment Verification Workflow

AFTER git push, ALWAYS:
1. Verify deployment status using Vercel MCP:
   - Use `list_deployments` to get latest deployment
   - Use `get_deployment` to check deployment state
   - If state is BUILDING, wait and check again until state is READY or ERROR
   - Use `get_deployment_build_logs` to check for errors if needed
2. If deployment has errors:
   - Check build logs for TypeScript errors, build failures, or other issues
   - Fix errors immediately
   - Commit and push fixes
   - Verify deployment status again (wait for BUILDING to complete)
3. If deployment is READY:
   - Deployment is successful and live
   - Check for any database migrations that need to be applied
   - Verify application is working correctly
4. NEVER consider deployment complete until state is READY (not BUILDING)

Supabase Database Operations

ALWAYS use Supabase MCP for database operations. Never use Supabase CLI commands for migrations or database changes.

For migrations:
- Create migration file: Use CLI only (`npm run supabase:migration:new <name>`) to create the file
- Apply migration: ALWAYS use Supabase MCP `apply_migration` tool, never use `supabase db push` or CLI commands
- Query database: ALWAYS use Supabase MCP `execute_sql` tool
- List tables: ALWAYS use Supabase MCP `list_tables` tool
- Generate TypeScript types: ALWAYS use Supabase MCP `generate_typescript_types` tool
- View logs: ALWAYS use Supabase MCP `get_logs` tool
- List migrations: ALWAYS use Supabase MCP `list_migrations` tool to check applied migrations

When deploying with database changes:
1. Create migration file locally using CLI: `npm run supabase:migration:new <name>`
2. Write migration SQL in the file
3. Apply migration using Supabase MCP: Use `apply_migration` tool in Cursor chat
4. Commit and push to git (Vercel deploys automatically)
5. After push, verify deployment status using Vercel MCP
6. Verify migration was applied using Supabase MCP `list_migrations` tool

Never run `supabase db push`, `npx supabase db push`, or any CLI database push commands.

Update Detection System

Service Worker Auto-Detection (No Manual Version Management!)

How It Works:
- Service Worker automatically detects new builds by comparing bundle hashes
- Works for ANY code change (no version updates needed!)
- Pull-to-refresh triggers: serviceWorkerRegistration.update()
- If new bundle found → Shows yellow update button
- User taps → App reloads with latest code

What This Eliminates:
- ❌ No package.json version updates required
- ❌ No src/lib/api/version.ts updates
- ❌ No database app_versions table dependency
- ❌ No GitHub Actions for version sync
- ❌ No version check API calls
- ❌ No 401/network errors from version checks

Simple Deployment Workflow:
```bash
# Make ANY change
git add .
git commit -m "your changes"
git push origin main

# Service Worker detects new bundle automatically
# Pull-to-refresh shows update immediately
```

Development


Design mobile-first (390px width, touch-friendly).


Use React functional components with hooks + TypeScript.


Ensure Supabase queries follow RLS and type safety.


Include loading + error states for all async tasks.


Validate forms and maintain consistent UI.


Use code splitting, lazy loading, and WebP images.


Track bundle size and performance metrics.


Keep formatting clean and consistent.


Prioritize performance optimization.


Documentation Files

NEVER create .md documentation files unless explicitly requested by the user.

Prefer communicating information via chat instead of creating documentation files.

Do not create test results, summaries, deployment logs, or other documentation files automatically.

Only create .md files when the user explicitly asks for documentation to be written.
